package chapter5

import (
	"encoding/hex"
	"errors"
	"fmt"
	"github.com/btcsuite/btcd/chaincfg"
	"github.com/btcsuite/btcutil"
	"github.com/btcsuite/btcutil/hdkeychain"
	"github.com/tyler-smith/go-bip39"
	"strings"
)

type Address struct {
	Address    string `json:"address"`
	PublicKey  string `json:"publickey"`
	PrivateKey string `json:"privatekey"`
}

func bip44(pkb []byte) (*Address, error) {
	net := chaincfg.MainNetParams
	// NewMaster creates a new master node for use in creating a hierarchical
	// deterministic key chain.  The seed must be between 128 and 512 bits and
	// should be generated by a cryptographically secure random generation source.
	//
	// NOTE: There is an extremely small chance (< 1 in 2^127) the provided seed
	// will derive to an unusable secret key.  The ErrUnusable error will be
	// returned if this should occur, so the caller must check for it and generate a
	// new seed accordingly.

	// NewMaster 创建用于创建分层确定性密钥串的主私钥（Master Private Key）
	// 种子必须在128到512位之间，并且应该由加密安全的随机生成源生成。

	// 注：提供种子几乎不可能性（<1/2^127） 派生到一个不可用的密钥。
	// 如果发生这种情况，不可用的错误将返回，
	// 因此调用方必须检查并生成相应的新种子。
	ext, err := hdkeychain.NewMaster(pkb, &net)
	if err != nil {
		return nil, errors.New("Bip32 root key generation failed:" + err.Error())
	}

	// m/44'

	// Child returns a derived child extended key at the given index.  When this
	// extended key is a private extended key (as determined by the IsPrivate
	// function), a private extended key will be derived.  Otherwise, the derived
	// extended key will be also be a public extended key.

	// Child 通过给定的索引号返回一个衍生子拓展密钥
	// 当这个拓展密钥是一个私钥（根据IsPrivate函数确定，那么获得的是拓展私钥
	// 否则返回的是拓展公钥

	// 根据协议bip-44，第一层推导使用的索引号是0x8000002C（硬化衍生：使用父私钥推导子私钥和子链码）
	purpose, err := ext.Child(44 + hdkeychain.HardenedKeyStart)
	if err != nil {
		return nil, errors.New("Bip44 purpose (m/44') failed:" + err.Error())
	}

	// m/44'/altcointype'
	// https://github.com/satoshilabs/slips/blob/master/slip-0044.md
	// 根据协议bip-44，第二层推导CoinType(各个币种详见上连接)，比特币主网索引号是1
	coinType, err := purpose.Child(uint32(0) + hdkeychain.HardenedKeyStart)
	if err != nil {
		return nil, errors.New("Bip44 coin_type (m/44'/coin_type') failed:" + err.Error())
	}

	// m/44'/altcointype'/0'
	// 根据协议bip-44，第三层推导Account(账号索引，从0开始)，
	acct0, err := coinType.Child(0 + hdkeychain.HardenedKeyStart)
	if err != nil {
		return nil, errors.New("Bip44 first account (m/44'/coin_type'/0') failed:" + err.Error())
	}

	// Account extended private key (eg to import in electrum)
	//account.Key = acct0

	// m/44'/altcointype'/0'/0
	// 0 = external accounts for receive addresses
	// 1 = internal accounts for change

	// 根据协议bip-44，第四层推导是Change（常量 0 用于外部链，常量 1 用于内部链）
	// 不是硬化衍生
	acct0External, err := acct0.Child(0)
	if err != nil {
		return nil, err
	}
	//account.External = acct0External

	// 根据协议bip-44，第五层推导是address_index（地址索引，从 0 开始，代表生成第几个地址，官方建议，每个 account 下的 address_index 不要超过 20）
	// 不是硬化衍生
	receive, err := acct0External.Child(uint32(0))
	if err != nil {
		return nil, errors.New("Failed to create receive address:" + err.Error())
	}
	// ECPrivKey converts the extended key to a btcec private key and returns it.
	// As you might imagine this is only possible if the extended key is a private
	// extended key (as determined by the IsPrivate function).  The ErrNotPrivExtKey
	// error will be returned if this function is called on a public extended key.

	// ECPrivKey 把拓展密钥转换成为基于ECDSA算法的私钥
	// 只能是衍生私钥，不能是拓展公钥，否则会报错
	privk, err := receive.ECPrivKey()
	if err != nil {
		return nil, errors.New("ECPrivKey() failed:" + err.Error())
	}

	// ECPubKey converts the extended key to a btcec public key and returns it.

	// ECPubKey 把拓展密钥转换成为基于ECDSA算法的公钥
	pubk, err := receive.ECPubKey()
	if err != nil {
		return nil, errors.New("ECPubKey() failed:" + err.Error())
	}

	// Address converts the extended key to a standard bitcoin pay-to-pubkey-hash
	// address for the passed network.
	address, err := receive.Address(&net)
	if err != nil {
		return nil, errors.New("Address conversion failed:" + err.Error())
	}

	// NewWIF creates a new WIF structure to export an address and its private key
	// as a string encoded in the Wallet Import Format.  The compress argument
	// specifies whether the address intended to be imported or exported was created
	// by serializing the public key compressed rather than uncompressed.
	wif, err := btcutil.NewWIF(privk, &net, true)
	if err != nil {
		return nil, errors.New("WIF creation failed:" + err.Error())
	}

	fmt.Println("address: %v", address.String())
	fmt.Println("private key %v", wif.String())
	fmt.Println("public key %v", hex.EncodeToString(pubk.SerializeCompressed()))

	addr := Address{address.String(),
		hex.EncodeToString(pubk.SerializeCompressed()), wif.String()}

	return &addr, nil
}

// validate word size is legal
// 验证单词个数是否合法， 长度[12，24]，且必须是3的倍数
func validateWordSize(wordSize int) bool {
	if wordSize < 12 || wordSize > 24 || wordSize%3 != 0 {
		return false
	}
	return true
}

// generate seed words (mnemonic)
func genMnemonic(wordSize int) (string, error) {

	if !validateWordSize(wordSize) {
		return "", errors.New(
			"Word size must be [3, 24] and a multiple of 3")
	}
	// calculate bitSize
	bitSize := wordSize * 11 * 32 / 33
	// 24 * 11 - (x/32) = x
	// NewEntropy will create random entropy bytes
	entropy, err := bip39.NewEntropy(bitSize)
	if err != nil {
		return "", errors.New(
			"Failed to generate entropy:" + err.Error())
	}

	// generate (english) seed words based on the entropy
	mnemonic, err := bip39.NewMnemonic(entropy)
	if err != nil {
		return "", errors.New(
			"Failed to generate mnemonic:" + err.Error())
	}
	return mnemonic, nil
}

func genUnRepeatMnemonic(wordSize int) (string, error) {
	mnemonic, err := genMnemonic(wordSize)
	if err != nil {
		return "", err
	}

	for IsHasRepeatMnemonic(mnemonic) {
		mnemonic, err = genMnemonic(wordSize)
		if err != nil {
			return "", err
		}
	}

	return mnemonic, nil
}

func IsHasRepeatMnemonic(mnemonic string) bool {
	words := strings.Split(mnemonic, " ")
	return isHasRepeatElement(words)
}

func isHasRepeatElement(eles []string) bool {

	for i := 0; i < len(eles); i++ {
		for j := i + 1; j < len(eles); j++ {
			if eles[i] == eles[j] {
				return true
			}
		}
	}
	return false
}
